(* Name: Kristin Mills *)

(* Course: UVM CS 225 Spring 2018 - Darais *)
(* Final Project: Exceptions *)

open Util
open StringSetMap

(**************************
 * Syntax for types*
 **************************)

(* X âˆˆ tvar â‰ˆ ð•Š
 * Ï„ âˆˆ type â©´ bool | nat | Ï„ Ã— Ï„ | Ï„ â†’ Ï„
 *)
type tvar = string
[@@deriving show {with_path = false}]

type ty =
  | Bool
  | Nat
  | Prod of ty * ty
  | Fun of ty * ty
[@@deriving show {with_path = false}]

(**************************
 * Syntax for expressions *
 **************************)

(* x âˆˆ var â‰ˆ ð•Š
 *)
type var = string
[@@deriving show {with_path = false}]

(* e âˆˆ exp â©´ true | false | if(e)(e)(e)
 *         | zero | succ(e) | pred(e) | iszero(e)
 *         | âŸ¨e,eâŸ© | projl(e) | projr(e)
 *         | x | let x â‰” e in e | Î»(x:Ï„).e | e(e)
 *         | raise(e) | try(e)with(e)
 *)
type exp =
  | True
  | False
  | If of exp * exp * exp
  | Zero
  | Succ of exp
  | Pred of exp
  | IsZero of exp
  | Pair of exp * exp
  | Projl of exp
  | Projr of exp
  | Var of var
  | Let of var * exp * exp
  | Lambda of var * ty * exp
  | Apply of exp * exp
  | Raise of exp
  | Try of exp * exp
[@@deriving show {with_path = false}]

(*********************
 * Syntax for values *
 *********************)

(* nv âˆˆ nval â©´ zero | succ(nv)
 *)
type natval =
  | VZero
  | VSucc of natval
[@@deriving show {with_path = false}]

(* v âˆˆ value â©´ true | false
 *           | n
 *           | âŸ¨v,vâŸ©
 *           | Î»(x:Ï„).e
 *)
type value =
  | VTrue
  | VFalse
  | VNat of natval
  | VPair of value * value
  | VLambda of var * ty * exp
[@@deriving show {with_path = false}]

(***********************************
 * Syntax for type system contexts *
 ***********************************)

(* Î“ âˆˆ tenv â‰” var â‡€ type
 *)
type tscope = string_set
[@@deriving show {with_path = false}]

(* S âˆˆ scope â‰” â„˜(tvar)
 *)
type tenv = ty string_map
[@@deriving show {with_path = false}]

(****************************
 * Free variables for types *
 ****************************)

(* FV âˆˆ type â†’ â„˜(tvar)
 * tfree_vars Ï„ â‰¡ FV(Ï„)
 *)
let rec tfree_vars (t0 : ty) : string_set = match t0 with
  | Bool -> StringSet.empty
  | Nat -> StringSet.empty
  | Prod(t1,t2) -> StringSet.union (tfree_vars t1) (tfree_vars t2)
  | Fun(t1,t2) -> StringSet.union (tfree_vars t1) (tfree_vars t2)

(**********************************
 * Free variables for expressions *
 **********************************)

(* FV âˆˆ exp â†’ â„˜(var)
 * efree_vars e â‰¡ FV(e)
 *)
let rec efree_vars (e0 : exp) : string_set = match e0 with
  | True -> StringSet.empty
  | False -> StringSet.empty
  | If(e1,e2,e3) ->
      StringSet.union
        (efree_vars e1)
        (StringSet.union (efree_vars e2) (efree_vars e3))
  | Zero -> StringSet.empty
  | Succ(e) -> efree_vars e
  | Pred(e) -> efree_vars e
  | IsZero(e) -> efree_vars e
  | Pair(e1,e2) -> StringSet.union (efree_vars e1) (efree_vars e2)
  | Projl(e) -> efree_vars e
  | Projr(e) -> efree_vars e
  | Var(x) -> StringSet.of_list [x]
  | Let(x,e1,e2) ->
      StringSet.union
        (efree_vars e1)
        (StringSet.remove x (efree_vars e2))
  | Lambda(x,t,e) ->
      StringSet.remove x (efree_vars e)
  | Apply(e1,e2) -> StringSet.union (efree_vars e1) (efree_vars e2)
  | Raise(e) -> efree_vars e
  | Try(e1,e2) -> StringSet.union (efree_vars e1) (efree_vars e2)

(***********************************************
 * Substitution for expressions in expressions *
 ***********************************************)

(* Non-capture-avoiding substitution for expressions in expressions. Because
 * this is non-capture-avoiding, it assumes that the expression being
 * substituted is closed.
 *
 *   esubst_e_i x eâ€² e
 *
 * Assumption: eâ€² is closed
 *
 * Do not use this function directly. Instead, use esubst_e which checks the
 * invariant.
 *)
let rec esubst_e_i (x : var) (e' : exp) (e0 : exp) : exp = match e0 with
  | True -> True
  | False -> False
  | If(e1,e2,e3) -> If(esubst_e_i x e' e1,esubst_e_i x e' e2,esubst_e_i x e' e3)
  | Zero -> Zero
  | Succ(e) -> Succ(esubst_e_i x e' e)
  | Pred(e) -> Pred(esubst_e_i x e' e)
  | IsZero(e) -> IsZero(esubst_e_i x e' e)
  | Pair(e1,e2) -> Pair(esubst_e_i x e' e1,esubst_e_i x e' e2)
  | Projl(e) -> Projl(esubst_e_i x e' e)
  | Projr(e) -> Projr(esubst_e_i x e' e)
  | Var(y) -> if x = y then e' else Var(y)
  | Let(y,e1,e2) ->
      if x = y
      then Let(x,esubst_e_i x e' e1,e2)
      else Let(y,esubst_e_i x e' e1,esubst_e_i x e' e2)
  | Lambda(y,t,e) ->
      if x = y
      then Lambda(x,t,e)
      else Lambda(y,t,esubst_e_i x e' e)
  | Apply(e1,e2) -> Apply(esubst_e_i x e' e1,esubst_e_i x e' e2)
  | Raise(e) -> Raise((esubst_e_i x e' e))
  | Try(e1,e2) -> Try(esubst_e_i x e' e1,esubst_e_i x e' e2)

exception NOT_CLOSED_ERROR

(* A version of non-capture-avoiding substitution that raises an exception if
 * its required assumptions are not satisfied.
 *
 * [_â†¦_]_ âˆˆ var Ã— exp Ã— exp â†’ exp
 * esubst_e x eâ€² e â‰¡ [xâ†¦eâ€²]e
 *
 * Raises exception if eâ€² is not closed
 *)
let esubst_e (x : var) (e' : exp) (e : exp) : exp =
  if StringSet.equal (efree_vars e') StringSet.empty
  then esubst_e_i x e' e
  else raise NOT_CLOSED_ERROR

(*****************************************
 * Substitution for types in expressions *
 *****************************************)

(* Non-capture-avoiding substitution for types in expressions. Because this is
 * non-capture-avoiding, it assumes that the type being substituted is closed.
 *
 *   esubst_t_i X Ï„â€² e
 *
 * Assumption: Ï„â€² is closed
 *
 * Do not use this function directly. Instead, use esubst_t which checks the
 * invariant.
 *)
let rec esubst_t_i (xt : tvar) (t' : ty) (e0 : exp) : exp = match e0 with
  | True -> True
  | False -> False
  | If(e1,e2,e3) -> If(esubst_t_i xt t' e1,esubst_t_i xt t' e2,esubst_t_i xt t' e3)
  | Zero -> Zero
  | Succ(e) -> Succ(esubst_t_i xt t' e)
  | Pred(e) -> Pred(esubst_t_i xt t' e)
  | IsZero(e) -> IsZero(esubst_t_i xt t' e)
  | Pair(e1,e2) -> Pair(esubst_t_i xt t' e1,esubst_t_i xt t' e2)
  | Projl(e) -> Projl(esubst_t_i xt t' e)
  | Projr(e) -> Projr(esubst_t_i xt t' e)
  | Var(x) -> Var(x)
  | Let(x,e1,e2) -> Let(x,esubst_t_i xt t' e1,esubst_t_i xt t' e2)
  | Lambda(x,t,e) -> Lambda(x,tsubst xt t' t,esubst_t_i xt t' e)
  | Apply(e1,e2) -> Apply(esubst_t_i xt t' e1,esubst_t_i xt t' e2)
  | Raise(e) -> Raise(esubst_t_i xt t' e)
  | Try(e1,e2) -> Try(esubst_t_i xt t' e1,esubst_t_i xt t' e2)
(* A version of non-capture-avoiding substitution that raises an exception if
 * its required assumptions are not satisfied.
 *
 * [_â†¦_]_ âˆˆ tvar Ã— type Ã— exp â†’ exp
 * esubst_t X Ï„â€² e â‰¡ [Xâ†¦Ï„â€²]e
 *
 * Raises exception if Ï„â€² is not closed
 *)
let esubst_t (x : var) (t' : ty) (e : exp) : exp =
  if StringSet.equal (tfree_vars t') StringSet.empty
  then esubst_t_i x t' e
  else raise NOT_CLOSED_ERROR

(**********************************
 * Small step transition relation *
 **********************************)

(* Converting natval to exp *)
let rec exp_of_natval (nv0 : natval) : exp = match nv0 with
  | VZero -> Zero
  | VSucc(nv) -> Succ(exp_of_natval nv)

(* Converting val to exp *)
let rec exp_of_val (v0 : value) : exp = match v0 with
  | VTrue -> True
  | VFalse -> False
  | VNat(nv) -> exp_of_natval nv
  | VPair(v1,v2) -> Pair(exp_of_val v1,exp_of_val v2)
  | VLambda(x,t,e) -> Lambda(x,t,e)

(* A result is either a value, an expression, or the symbol `stuck`.
 *
 * r âˆˆ result â©´ v | e | stuck
 *)
type result =
  | Val of value
  | Step of exp
  | Stuck
[@@deriving show {with_path = false}]


(* The small-step relation e â€”â†’ e
 *
 * Assumption: e is closed.
 *
 * If step(e) = v, then e is a value (and does not take a step).
 * (i.e., e âˆˆ val)
 *
 * If step(e) = eâ€², then e steps to eâ€².
 * (i.e., e â€”â†’ eâ€²)
 *
 * If step(e) = stuck, then e is stuck, that is e is not a value and does not
 * take a step.
 * (i.e., e âˆ‰ val and e â€”â†›)
 *)
let rec step (e0 : exp) : result = match e0 with
  (* true âˆˆ val *)
  | True -> Val(VTrue)
  (* false âˆˆ val *)
  | False -> Val(VFalse)
  | If(e1,e2,e3) -> begin match step e1 with
      (* [If-True]
       * if(true){eâ‚‚}{eâ‚ƒ} â€”â†’ eâ‚‚ *)
      | Val(VTrue) -> Step(e2)
      (* [If-False]
       * if(false){eâ‚‚}{eâ‚ƒ} â€”â†’ eâ‚ƒ *)
      | Val(VFalse) -> Step(e3)
      (* v âˆ‰ {true,false}
       * âŸ¹
       * if(v){eâ‚‚}{eâ‚ƒ} âˆ‰ val
       * if(v){eâ‚‚}{eâ‚ƒ} â€”â†› *)
      | Val(_) -> Stuck
      (* [If-Cong]
       * eâ‚ â€”â†’ eâ‚â€²
       * âŸ¹
       * if(eâ‚){eâ‚‚}{eâ‚ƒ} â€”â†’ if(eâ‚â€²){eâ‚‚}{eâ‚ƒ} *)
      | Step(e1') -> Step(If(e1',e2,e3))
      (* eâ‚ âˆ‰ val
       * eâ‚ â€”â†›
       * âŸ¹
       * if(eâ‚){eâ‚‚}{eâ‚ƒ} âˆ‰ val
       * if(eâ‚){eâ‚‚}{eâ‚ƒ} â€”â†› *)
      | Stuck -> Stuck
      end
  (* zero âˆˆ val *)
  | Zero -> Val(VNat(VZero))
  | Succ(e) -> begin match step e with
      (* nv âˆˆ nval
       * âŸ¹
       * succ(nv) âˆˆ nval âŠ† val *)
      | Val(VNat(nv)) -> Val(VNat(VSucc(nv)))
      (* v âˆ‰ nval
       * âŸ¹
       * succ(v) âˆ‰ val
       * succ(v) â€”â†› *)
      | Val(_) -> Stuck
      (* [Succ-Cong]
       * e â€”â†’ eâ€²
       * succ(e) â€”â†’ succ(eâ€²) *)
      | Step(e') -> Step(Succ(e'))
      (* e âˆ‰ val
       * e â€”â†›
       * âŸ¹
       * succ(e) âˆ‰ val
       * succ(e) â€”â†› *)
      | Stuck -> Stuck
      end
  | Pred(e) -> begin match step e with
      (* [Pred-Zero]
       * pred(zero) â€”â†’ zero *)
      | Val(VNat(VZero)) -> Step(Zero)
      (* [Pred-Succ]
       * pred(succ(nv)) â€”â†’ nv *)
      | Val(VNat(VSucc(nv))) -> Step(exp_of_natval nv)
      (* v âˆ‰ nval
       * âŸ¹
       * pred(v) âˆ‰ val
       * pred(v) â€”â†› *)
      | Val(_) -> Stuck
      (* [Pred-Cong]
       * e â€”â†’ eâ€²
       * âŸ¹
       * pred(e) â€”â†’ pred(eâ€²) *)
      | Step(e') -> Step(Pred(e'))
      (* e âˆ‰ val
       * e â€”â†›
       * âŸ¹
       * pred(e) âˆ‰ val
       * pred(e) â€”â†› *)
      | Stuck -> Stuck
      end
  | IsZero(e) -> begin match step e with
      (* [IsZero-Zero]
       * iszero(zero) â€”â†’ true *)
      | Val(VNat(VZero)) -> Step(True)
      (* [IsZero-Succ]
       * iszero(succ(nv)) â€”â†’ false *)
      | Val(VNat(VSucc(nv))) -> Step(False)
      (* v âˆ‰ nval
       * âŸ¹
       * iszero(v) âˆ‰ val
       * iszero(v) â€”â†› *)
      | Val(_) -> Stuck
      (* [IsZero-Cong]
       * e â€”â†’ eâ€²
       * âŸ¹
       * iszero(e) â€”â†’ iszero(eâ€²) *)
      | Step(e') -> Step(IsZero(e'))
      (* e âˆ‰ val
       * e â€”â†›
       * âŸ¹
       * iszero(e) âˆ‰ val
       * iszero(e) â€”â†› *)
      | Stuck -> Stuck
      end
  | Pair(e1,e2) -> begin match step e1 with
      | Val(v1) -> begin match step e2 with
          (* âŸ¨vâ‚,vâ‚‚âŸ© âˆˆ val *)
          | Val(v2) -> Val(VPair(v1,v2))
          (* [Pair-Cong-2]
           * e â€”â†’ eâ€²
           * âŸ¹
           * âŸ¨v,eâŸ© â€”â†’ âŸ¨v,eâ€²âŸ© *)
          | Step(e2') -> Step(Pair(e1,e2'))
          (* e âˆ‰ val
           * e â€”â†›
           * âŸ¹
           * âŸ¨v,eâŸ© âˆ‰ val
           * âŸ¨v,eâŸ© â€”â†› *)
          | Stuck -> Stuck
          end
      (* [Pair-Cong-1]
       * eâ‚ â€”â†’ eâ‚â€²
       * âŸ¹
       * âŸ¨eâ‚,eâ‚‚âŸ© â€”â†’ âŸ¨eâ‚â€²,eâ‚‚âŸ© *)
      | Step(e1') -> Step(Pair(e1',e2))
      (* eâ‚ âˆ‰ val
       * eâ‚ â€”â†›
       * âŸ¹
       * âŸ¨eâ‚,eâ‚‚âŸ© âˆ‰ val
       * âŸ¨eâ‚,eâ‚‚âŸ© â€”â†› *)
      | Stuck -> Stuck
      end
  | Projl(e1) -> begin match step e1 with
      (* [Projl-Pair]
       * projl(âŸ¨vâ‚,vâ‚‚âŸ©) â€”â†’ vâ‚ *)
      | Val(VPair(v1,v2)) -> Step(exp_of_val v1)
      (* âˆ„vâ‚,vâ‚‚. v = âŸ¨vâ‚,vâ‚‚âŸ©
       * âŸ¹
       * projl(v) âˆ‰ val
       * projl(v) â€”â†› *)
      | Val(_) -> Stuck
      (* [Projl-Cong]
       * e â€”â†’ eâ€²
       * âŸ¹
       * projl(e) â€”â†’ projl(eâ€²) *)
      | Step(e1') -> Step(Projl(e1'))
      (* e âˆ‰ val
       * e â€”â†›
       * âŸ¹
       * projl(e) âˆ‰ val
       * projl(e) â€”â†› *)
      | Stuck -> Stuck
      end
  | Projr(e1) -> begin match step e1 with
      (* [Projr-Pair]
       * projr(âŸ¨vâ‚,vâ‚‚âŸ©) â€”â†’ vâ‚‚ *)
      | Val(VPair(v1,v2)) -> Step(exp_of_val v2)
      (* âˆ„vâ‚,vâ‚‚. v = âŸ¨vâ‚,vâ‚‚âŸ©
       * âŸ¹
       * projr(v) âˆ‰ val
       * projr(v) â€”â†› *)
      | Val(_) -> Stuck
      (* [Projr-Cong]
       * e â€”â†’ eâ€²
       * âŸ¹
       * projr(e) â€”â†’ projr(eâ€²) *)
      | Step(e1') -> Step(Projr(e1'))
      (* e âˆ‰ val
       * e â€”â†›
       * âŸ¹
       * projr(e) âˆ‰ val
       * projr(e) â€”â†› *)
      | Stuck -> Stuck
      end
  (* x is not closed *)
  | Var(x) -> raise NOT_CLOSED_ERROR
  | Let(x,e1,e2) -> begin match step e1 with
      (* [Let-Val]
       * let x â‰” v in e â€”â†’ [xâ†¦v]e *)
      | Val(v1) -> Step(esubst_e x (exp_of_val v1) e2)
      (* [Let-Cong]
       * eâ‚ â€”â†’ eâ‚â€²
       * âŸ¹
       * let x â‰” eâ‚ in eâ‚‚ â€”â†’ let x = eâ‚â€² in eâ‚‚ *)
      | Step(e1') -> Step(Let(x,e1',e2))
      (* eâ‚ âˆ‰ val
       * eâ‚ â€”â†›
       * âŸ¹
       * let x â‰” eâ‚ in eâ‚‚ âˆ‰ val
       * let x â‰” eâ‚ in eâ‚‚ â€”â†› *)
      | Stuck -> Stuck
      end
  (* Î»(x:Ï„).e âˆˆ val *)
  | Lambda(x,t,e) -> Val(VLambda(x,t,e))
  | Apply(e1,e2) -> begin match step e1 with
      | Val(v1) -> begin match step e2 with
          | Val(v2) -> begin match v1 with
              (* [Apply-Lambda (Î²)]
               * (Î»(x:Ï„).e)v â€”â†’ [xâ†¦v]e *)
              | VLambda(x,t,e) -> Step(esubst_e x (exp_of_val v2) e)
              (* âˆ„x,Ï„,e. vâ‚ = Î»(x:Ï„).e
               * âŸ¹
               * vâ‚(vâ‚‚) âˆ‰ val
               * vâ‚(vâ‚‚) â€”â†› *)
              | _ -> Stuck
              end
          (* [E-App-Raise-2]
           * vâ‚(raise vâ‚‚â‚) â€”â†’ raise vâ‚‚â‚*)
          | Raise(v21) -> Step(Raise(exp_of_val v21))
          (* [Apply-Cong-2]
           * e â€”â†’ eâ€²
           * âŸ¹
           * v(e) â€”â†’ v(eâ€²) *)
          | Step(e2') -> Step(Apply(e1,e2'))
          (* e âˆ‰ val
           * e â€”â†›
           * âŸ¹
           * v(e) âˆ‰ val
           * v(e) â€”â†› *)
          | Stuck -> Stuck
          end
      (* [E-App-Raise-1]
       * (raise vâ‚â‚)eâ‚‚ â€”â†’ raise vâ‚â‚*)
      | Raise(v11) -> Step(Raise(exp_of_val v11))
      (* [Apply-Cong-1]
       * eâ‚ â€”â†’ eâ‚â€²
       * âŸ¹
       * eâ‚(eâ‚‚) â€”â†’ eâ‚â€²(eâ‚‚) *)
      | Step(e1') -> Step(Apply(e1',e2))
      (* eâ‚ âˆ‰ val
       * eâ‚ â€”â†›
       * âŸ¹
       * eâ‚(eâ‚‚) âˆ‰ val
       * eâ‚(eâ‚‚) â€“â†› *)
      | Stuck -> Stuck
      end
  | Raise(e1) -> begin match step e1 with
      (* [E-RaiseRaise]
       * raise(raise vâ‚â‚) â€”â†’ raise vâ‚â‚ *)
      | Raise(v11) -> Step(Raise(exp_of_val v11))
      (* [E-Raise]
       * eâ‚ â€”â†’ eâ‚â€²
       * âŸ¹
       * raise eâ‚ â€”â†’ raise eâ‚â€² *)
      | Step(e1') -> Step(Raise(e1'))
      (* eâ‚ âˆ‰ val
       * eâ‚ â€”â†›
       * âŸ¹
       * raise eâ‚ âˆ‰ val
       * raise eâ‚ â€“â†› *)
      | Stuck -> Stuck
      end
  | Try(e1,e2) -> begin match step e1 with
      (* [E-TryV]
       * try vâ‚ with tâ‚‚ â€”â†’ vâ‚ *)
      | Val(v1) -> Step(exp_of_val v1)
      (* [E-TryRaise]
       * try raise vâ‚â‚ with tâ‚‚ â€”â†’ tâ‚‚ vâ‚â‚ *)
      | Raise(v11) -> Step(Apply(e2,exp_of_val v11))
      (* [E-Try]
       * eâ‚ â€”â†’ eâ‚â€²
       * âŸ¹
       * try eâ‚ with eâ‚‚ â€”â†’ try eâ‚â€² with eâ‚‚ *)
      | Step(e1') -> Step(Try(e1',e2))
      (* eâ‚ âˆ‰ val
       * eâ‚ â€”â†›
       * âŸ¹
       * try eâ‚ with eâ‚‚ âˆ‰ val
       * try eâ‚ with eâ‚‚ â€“â†› *)
      | Stuck -> Stuck

(* The reflexive transitive closure of the small-step relation e â€”â†’* e *)
let rec step_star (e : exp) : exp = match step e with
  | Val(v) -> exp_of_val v
  | Step(e') -> step_star e'
  | Stuck -> e

(***********************
 * Well-typed relation *
 ***********************)

(* An auxiliary function for testing the equality of two types, modulo alpha
 * conversion.
 *
 * First, a helper function tequal_r which keeps track of which bindings are
 * equal by assigning them to unique numbers.
 *)
let rec tequal_r (l : int) (t1e : int string_map) (t2e : int string_map) (t1 : ty) (t2 : ty) : bool = match t1 , t2 with
  | Bool , Bool -> true
  | Nat , Nat -> true
  | Fun(t11,t12) , Fun(t21,t22) -> tequal_r l t1e t2e t11 t21 && tequal_r l t1e t2e t12 t22
  | Prod(t11,t12) , Prod(t21,t22) -> tequal_r l t1e t2e t11 t21 && tequal_r l t1e t2e t12 t22
  | _ , _ -> false

(* tequal Ï„â‚ Ï„â‚‚ = true âŸº  Ï„â‚ â‰ˆáµ… Ï„â‚‚
 *
 * !! use tequal in your implementation of infer anytime you need to compare
 * two types for equality
 *)
let tequal (t1 : ty) (t2 : ty) : bool = tequal_r 1 StringMap.empty StringMap.empty t1 t2

exception TYPE_ERROR

(* The relation:
 *   Î“ âŠ¢ e : Ï„
 * infer Î“ e = Ï„ âŸº  Î“ âŠ¢ : Ï„
 *)
let rec infer (g : tenv) (e0 : exp) : ty = match e0 with
  (* [True]
   * Î“ âŠ¢ true : bool *)
  | True -> Bool
  (* [False]
   * Î“ âŠ¢ false : bool *)
  | False -> Bool
  (* [If]
   * Î“ âŠ¢ eâ‚ : bool
   * Î“ âŠ¢ eâ‚‚ : Ï„
   * Î“ âŠ¢ eâ‚ƒ : Ï„
   * âŸ¹
   * Î“ âŠ¢ if(eâ‚){eâ‚‚}{eâ‚ƒ} : Ï„ *)
  | If(e1,e2,e3) ->
      let t1 = infer g e1 in
      let t2 = infer g e2 in
      let t3 = infer g e3 in
      if not (t1 = Bool) then raise TYPE_ERROR else
      if not (t2 = t3) then raise TYPE_ERROR else
      t2
  (* [Zero]
   * Î“ âŠ¢ zero : nat *)
  | Zero -> Nat
  (* [Succ]
   * Î“ âŠ¢ e : nat
   * âŸ¹
   * Î“ âŠ¢ succ(e) : nat *)
  | Succ(e) ->
      let t = infer g e in
      if not (t = Nat) then raise TYPE_ERROR else
      Nat
  (* [Pred]
   * Î“ âŠ¢ e : nat
   * âŸ¹
   * Î“ âŠ¢ pred(e) : nat *)
  | Pred(e) ->
      let t = infer g e in
      if not (t = Nat) then raise TYPE_ERROR else
      Nat
  (* [IsZero]
   * Î“ âŠ¢ e : nat
   * âŸ¹
   * Î“ âŠ¢ iszero(e) : bool *)
  | IsZero(e) ->
      let t = infer g e in
      if not (t = Nat) then raise TYPE_ERROR else
      Bool
  (* [Pair]
   * Î“ âŠ¢ eâ‚ : Ï„â‚
   * Î“ âŠ¢ eâ‚‚ : Ï„â‚‚
   * âŸ¹
   * Î“ âŠ¢ âŸ¨eâ‚,eâ‚‚âŸ© : Ï„â‚ Ã— Ï„â‚‚ *)
  | Pair(e1,e2) ->
      let t1 = infer g e1 in
      let t2 = infer g e2 in
      Prod(t1,t2)
  (* [Projl]
   * Î“ âŠ¢ e : Ï„â‚ Ã— Ï„â‚‚
   * âŸ¹
   * Î“ âŠ¢ projl(e) : Ï„â‚ *)
  | Projl(e) ->
      let t = infer g e in
      begin match t with
      | Prod(t1,_) -> t1
      | _ -> raise TYPE_ERROR
      end
  (* [Projr]
   * Î“ âŠ¢ e : Ï„â‚ Ã— Ï„â‚‚
   * âŸ¹
   * Î“ âŠ¢ projr(e) : Ï„â‚‚ *)
  | Projr(e) ->
      let t = infer g e in
      begin match t with
      | Prod(_,t2) -> t2
      | _ -> raise TYPE_ERROR
      end
  (* [Var]
   * Î“(x) = Ï„
   * âŸ¹
   * Î“ âŠ¢ x : Ï„ *)
  | Var(x) -> StringMap.find x g
  (* [Var]
   * Î“ âŠ¢ eâ‚ : Ï„â‚
   * Î“[xâ†¦Ï„â‚] âŠ¢ eâ‚‚ : Ï„â‚‚
   * âŸ¹
   * Î“ âŠ¢ let x â‰” eâ‚ in eâ‚‚ : Ï„â‚‚ *)
  | Let(x,e1,e2) ->
      let t = infer g e1 in
      infer (StringMap.add x t g) e2
  (* [Lambda]
   * Î“[xâ†¦Ï„â‚] âŠ¢ e : Ï„â‚‚
   * âŸ¹
   * Î“ âŠ¢ Î»(x:Ï„â‚).e : Ï„â‚ â†’ Ï„â‚‚ *)
  | Lambda(x,t1,e) ->
      let t2 = infer (StringMap.add x t1 g) e in
      Fun(t1,t2)
  (* [Apply]
   * Î“ âŠ¢ eâ‚ : Ï„â‚ â†’ Ï„â‚‚
   * Î“ âŠ¢ eâ‚‚ : Ï„â‚
   * âŸ¹
   * Î“ âŠ¢ eâ‚(eâ‚‚) : Ï„â‚‚ *)
  | Apply(e1,e2) ->
      let t1 = infer g e1 in
      let t2 = infer g e2 in
      begin match t1 with
      | Fun(t11,t12) ->
          if not (t11 = t2) then raise TYPE_ERROR else
          t12
      | _ -> raise TYPE_ERROR
      end
  (* [Raise] ------ NEED TO FIX THIS ONE
   * Î“ âŠ¢ eâ‚ : Ï„exn
   * âŸ¹
   * Î“ âŠ¢ raise eâ‚ : Ï„â‚‚ *)
  | Raise(e) ->
      let t1 = infer g e in
      begin match t1 with
        | exn -> t2
        | _ -> raise TYPE_ERROR
      end
  (* [Try]
   * Î“ âŠ¢ eâ‚ : Ï„â‚
   * Î“ âŠ¢ eâ‚‚ : Ï„exn â†’ Ï„â‚
   * âŸ¹
   * Î“ âŠ¢ try eâ‚ with eâ‚‚ : Ï„â‚ *)
  | Try(e1,e2) ->
      let t1 = infer g e1 in
      let t2 = infer g e2 in
      begin match t2 with
        | Fun(t11,t12) ->
          if not (t11 = exn) then raise TYPE_ERROR else
          if not (t12 = t1) then raise TYPE_ERROR else
            t1
        | _ -> raise TYPE_ERROR
      end

(***********
 * Testing *
 ***********)

(**************************************************
 * Medium Sized Program of Real World Application *
 **************************************************)


(* Name: Kristin Mills *)
